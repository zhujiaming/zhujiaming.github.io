{"meta":{"title":"jiaming","subtitle":"这里什么都没有...","description":"这里什么都没有...","author":"jiaming.zhu","url":"http://zhujm.top","root":"/"},"pages":[],"posts":[{"title":"🔥欢迎下载体验「小号」应用","slug":"201908160914","date":"2019-08-16T01:14:59.000Z","updated":"2019-08-16T02:00:06.541Z","comments":true,"path":"2019/08/16/201908160914/","link":"","permalink":"http://zhujm.top/2019/08/16/201908160914/","excerpt":"小号是一款互联网共享短信查看神器 立即下载👇","text":"小号是一款互联网共享短信查看神器 立即下载👇 一款收集展示互联网共享短信的应用，收纳的手机号多达上百个，并且不定期更新增加新的平台手机号。 在日常测试工作中，需要大量的测试账号，而互联网上有此类的共享手机号提供公开的短信共享，这样就能满足大量测试号的需求，但目前此类网站比较分散。 因此开发了该app用于收集整合互联网此类平台，并统一在该app上展示，应用架构上支持拓展更多的平台，未来将支持更多的短信或手机号操作。 🍺泼冷水1.0版本由于设计简陋功能比较单一，上线应用商店被拒了。（确实很简陋单一，😄，所以目前定位学习交流） 不过这是个人开发的第一款饱含激情与希望的应用，也算是不忘初心吧，从有想法到出成品经历了四五个月总算挤出来了，出1.0版本了。 有兴趣的同学可以下载体验下，还是比较实用哦，也欢迎一起学习交流提意见，更欢迎有想法小伙伴一起合作开发😝。 🍺下面时间简单欣赏下由开发者设计的丑陋的界面吧 🍻谢谢阅读！","categories":[{"name":"个人项目","slug":"个人项目","permalink":"http://zhujm.top/categories/个人项目/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhujm.top/tags/android/"}]},{"title":"AndriodStudio打开项目长时间无响应解决","slug":"201908151038","date":"2019-06-11T05:02:58.000Z","updated":"2019-08-16T01:41:34.451Z","comments":true,"path":"2019/06/11/201908151038/","link":"","permalink":"http://zhujm.top/2019/06/11/201908151038/","excerpt":"首次安装 AndroidStudio 后，基本都会经历一个漫长的 Gradle 构建工具下载过程，避免这个漫长的等待，那就只有手动下载。","text":"首次安装 AndroidStudio 后，基本都会经历一个漫长的 Gradle 构建工具下载过程，避免这个漫长的等待，那就只有手动下载。 手动下载 Gradle 构建工具并设置步骤： 打开 项目目录/gradle/wrapper/gradle-wrapper.properties 查看 distributionUrl 的值的 gradle 版本号（如：gradle-2.4-all.zip），便获得了该项目所需 Gradle 构建工具版本 点击这里或官方渠道选择相应的版本下载，下载速度相比 as 肯定快不少 下载完成，打开 user 目录下的一个/.gradle 文件夹(windows 与 mac 相似，都是用户目录下，并且需要设置显示隐藏文件，具体百度即可，如果没有./gradle，运行一遍 AndroidStudio，跑个项目后 kill AndroidStudio 便有了) 找到/.gradle/wrapper/dist/ 目录下肯定会有 gradle-x.x-all 的文件夹，且对应项目所需的版本号（没有则把该项目导入 AndroidStudio，然后在 as 下载过程中强制结束 as，即可找到该文件夹） 把上面下载好的 jar 包丢进去，重新跑 AndroidStudio，这时，便正常啦。","categories":[{"name":"devTools","slug":"devTools","permalink":"http://zhujm.top/categories/devTools/"}],"tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://zhujm.top/tags/AndroidStudio/"},{"name":"Gradle","slug":"Gradle","permalink":"http://zhujm.top/tags/Gradle/"}]},{"title":"风险投资的过程——《浪潮之巅》","slug":"201908151343","date":"2018-08-15T05:43:16.000Z","updated":"2019-08-16T01:38:41.192Z","comments":true,"path":"2018/08/15/201908151343/","link":"","permalink":"http://zhujm.top/2018/08/15/201908151343/","excerpt":"风险投资的过程其实就是一个科技公司创办的过程。","text":"风险投资的过程其实就是一个科技公司创办的过程。在美国，一个新兴的科技公司（Startups）的创业过程通常是这样的：来自思科公司的工程师山姆和IBM公司的工程师强尼发明了一种无线通信的技术，当然这种技术和他们所在公司的核心业务无关，两人觉得这种技术很有商业前景，他们就写了个专利草案，又花五千美元找了个专利律师，向美国专利局递交了专利申请（关键之一，知识产权很重要）。两个人下班后以及周末的所有时间全泡在山姆家的车库里用模拟软件 Matlab 进行模拟，证明这种技术可以将无线通信速度提高五十倍（关键之二，是否有数量级的提高是衡量一项新技术是革命性的还是革新性的关键。）两个人想了好几种应用，比如代替现有的计算机 Wifi，或者用到手机上，于是在原有的专利上又添加了两个补充性专利。强尼和山姆于是拿着自己做的 Powerpoint 投影胶片、实验结果和专利申请材料到处找投资者，在碰了七八次壁以后，找到了山姆原来的老板，思科早期雇员亚平。亚平从思科发了财后不再当技术主管了，自己和几个志同道合的有钱人一起在做天使投资人。亚平和不下百十来个创业者谈过投资，对新技术眼光颇为敏锐，发现山姆和强尼的技术很有独到之处，但是因为山姆和强尼讲不清楚这种技术的具体商业前景在哪里，建议他们找一个精通商业的人制定一个商业计划 Business Plan（关键之三，商业计划很重要）。强尼找到做市场和销售的朋友迪克，并向迪克大致介绍了自己的发明，希望迪克加盟共同开发市场。迪克觉得和这两个人谈得来，愿意共同创业。这时出现了第一次股权分配问题。到目前为止，所有的工作都是山姆和强尼做的，两个人各占未来公司的 50% 股权和投票权。迪克加盟后，三个人商定，如果迪克制定出一个商业计划书，他将获得 20% 的股权，山姆和强尼将减持到 40%。迪克经过调查发现，山姆和强尼的发明在高清晰度家庭娱乐中心的前景十分可观，于是制定了可行的商业计划书，并得到了 20% 的股权。三个人到目前为止对今后公司的所有权见下表。三个人再次找到亚平，亚平请他的朋友，斯坦福大学电机工程系的查理曼教授作了评估，证实了山姆等人的技术是先进的并有相当的复杂度，而且有专利保护，别人不易抄袭模仿。亚平觉得可以投资了，他和他的天使投资团觉得山姆、强尼和迪克的工作到目前为止值（未融资前）一百五十万美元，而三个创业者觉得他们的工作值二百五十万，最后商定定价二百万（注：对公司的估价方法有按融资前估价，即 Pre-Money ，和融资后估价，即 Post-Money 两种。从本质上讲，这两种方法是一样的，我们这里的估计都以 Pre-Money 来计算）。亚平和他的投资团投入五十万，占到股份的 20%。同时，亚平提出下列要求：1.亚平要成为董事会成员；2.山姆、强尼和迪克三人必须从原有公司辞职，全职为新公司工作。并且在没有新的投资进来以前，三个人的工资不得高于每月四千美元；3.山姆等三人的股票必须按月在今后的四年里逐步获得（Vested），而不是在公司成立时立即获得。这样如果其中有人离开了，他只能得到一部分股票；4.如果有新的任何融资行为必须通知亚平的天使投资团。现在山姆等人就必须正式成立公司了。为了将来融资和开展业务方便起见，他们在特拉华州注册了赛通科技有限公司。山姆任董事会主席、迪克和亚平任董事。山姆任总裁，强尼任主管技术的副总裁兼首席技术官，迪克任主管市场和营销的副总裁。三个人均为共同创始人。公司注册股票一千五百万股，内部核算价格每股二十美分。在亚平投资后（的那一瞬间），该公司的内部估计已经从两百万增加到二百五十万，以每股二十美分计算，所有股东的股票只占到 1250 万股（250万/0.2=1250万）。那么为什么会多出来 250 万股，它们并没有相应的资金或者技术做抵押，这些股票的存在实际上稀释了（Dilute）所有股东的股权。为什么公司自己要印这些空头钞票呢？因为它们必须留出来给下面的用途：1.由于山姆等人的工资很低，他们将根据自己的贡献，拿到一部分股票作为补偿；2.公司正式成立后需要雇人，需要给员工发股票期权；3.公司还有一些重要的成员没有进来，包括 CEO，他们将获得相当数量的股票。现在，该公司各位股东股权如下：接下来，山姆等人辞去以前的职务，全职创业。公司很成功，半年后做出了产品的原型（Prototype）。但是，50 万投资已经花完了，公司也发展到 20 多人。250 万股票也用去了 150 万股。这时，他们必须再融资。由于该公司前景可观，终于得到了红杉风投的青睐。红杉风投为该公司作价 1500 万美元，这时，该公司的股票每股值 1 美元了，比亚平投资时涨了四倍。红杉同意投资 500 万美元，占 25%，这样总股数增加到 2000 万股。同时，红杉风投将委派一人到该公司董事会任职。山姆等人还答应，由红杉风投帮助寻找一位职业经理人做公司的正式 CEO。双方还商定，融资后再稀释 5%，即 100 万股，为以后的员工发期权。现在该公司股权如下：读者也许已经注意到，红杉风投现在已经成为了最大的股东。两年后，该公司的样品研制成功，并获得东芝公司的订单，同时请到了前博通公司的 COO 比尔出任 CEO。比尔进入了董事会，并以每股三美元的价钱获得 100 万股的期权。当然新来的员工也用去一些未分配的股票。这时该公司的股价其实比红杉风投投资时，已经涨了两倍。比尔到任后，公司进一步发展，但是仍然没有盈利。于是，董事会决定再一次融资，由红杉风投领头协同另两家风投投资一千五百万。公司在投资时作价一亿五百万，即每股五美元。现在，该公司股权变为：这时，投资者的股份已占到 44%，和创始人相对，即拥有了一半左右的控制权。又过了两年，该公司开始盈利，并在高盛的帮助下增发六百万股，在纳斯达克上市，上市时原始股定价每股 25 美元。这样，一个科技公司在 VC 的帮助下便创办成功了。上市后，该公司总市值大约七亿五千万美元。该公司股权如下：这时，创始人山姆等人成了充满传奇色彩的亿万富翁，其员工共持有价值近五千万美元的股票，不少也成了百万富翁。但是，山姆等全体公司员工只持有 44% 的股份，公司的所有权的大部分从创始人和员工手里转移到投资者手中。一般来讲，一个创始人在公司上市时还能握有 10% 的股份已经很不错了。作为最早的投资者，亚平的天使投资团收益最高，高达一百二十四倍。红杉风投的第一轮获利二十四倍，第二轮和其它两家风投均获利四倍。显然，越早投资一个有希望的公司获利越大，当然，失败的可能性也越大。一般大的风投基金都会按一定比例投入到不同发展阶段的公司，这样既保证基本的回报，也保证有得到几十倍回报的机会。","categories":[{"name":"阅读","slug":"阅读","permalink":"http://zhujm.top/categories/阅读/"}],"tags":[{"name":"Note","slug":"Note","permalink":"http://zhujm.top/tags/Note/"}]},{"title":"A custom clock view .","slug":"201908151322","date":"2018-08-15T05:22:08.000Z","updated":"2019-08-16T01:39:05.635Z","comments":true,"path":"2018/08/15/201908151322/","link":"","permalink":"http://zhujm.top/2018/08/15/201908151322/","excerpt":"自己学习开发的一款基于安卓自定义View实现的机械手表View","text":"自己学习开发的一款基于安卓自定义View实现的机械手表View github传送门","categories":[{"name":"个人项目","slug":"个人项目","permalink":"http://zhujm.top/categories/个人项目/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhujm.top/tags/android/"}]},{"title":"关于Android设备已连接wifi密码的获取密码方式","slug":"201908151353","date":"2018-06-15T05:51:00.000Z","updated":"2019-08-16T01:38:35.000Z","comments":true,"path":"2018/06/15/201908151353/","link":"","permalink":"http://zhujm.top/2018/06/15/201908151353/","excerpt":"Android系统本身目前并不支持直接显示当前已连接wifi密码，","text":"Android系统本身目前并不支持直接显示当前已连接wifi密码，当Android设备连接wifi成功后，想要和他人分享wifi几乎是不大可能,（当然，我目前了解的如果是小米手机，直接可以通过wifi二维码信息获取到密码），下面记录两种简单的获取普通android设备已连接wifi密码的方式。 大致有两种方式可以获取到当前设备wifi的详细信息,分为root方式与非root方式 root方式安卓手机的ROOT：即为获取最高的权限，就跟电脑获取超级管理员一样的!因为厂家怕你不懂手机系统就设置了这样一个权限。你的手机没ROOT之前，你是以一个使用者的身份在用这个手机。你只能被动的使用里面的一些功能，或者在不影响系统全局的情况下安装一些新的程序。 准备一台已root的android设备通过软件root当前设备，获取管理员最高权限，可通过市面上一些手机root软件来操作，如root大师，360一键root等。 查看android设备是否已获取root权限在安卓手机中下载安装RE文件管理器（该软件在之后也会用到），下载后打开，如下图： 在箭头所指的地方，显示为已挂载为可读写，即为已root状态，当前文件夹下所有文件为可读写。 进入指定文件夹下在根目录下进入 /data/misc/wifi/ 目录下找到文件wpa_supplicant.conf： 以文本方式打开该文件打开后内容如图：其中，箭头所指ssid与psk分别为已连接过的wifi的名称与密码了。 当然，在已获取root权限的手机上下载wifi信息查看类的apk软件也是可以查看密码的，如 WIFI密码查看器。 非root方式 非root方式应用到android系统的备份功能，将wifi信息备份到sd卡的可读写目录中，打开相应文件如类似backup命名的文件夹中的相应文件便可查看密码。但是某些由于国产手机对安卓系统改造太大，部分国产品牌手机未对用户提供备份功能，或者备份数据进行了加密，无法查看，因此，该方法仅适用于部分手机。亲测目前只有少部分手机可采用这样的方式。具体方式百度经验上有介绍。 万能钥匙方式，该方式估计大多数人都知道，采用了热点连接分享与简单密码暴力破解的方式，热点连接分享估计就是采用万能钥匙自己的app进行wifi连接时，万能钥匙就能获取到wifi信息以及当前地点信息，再备份到网络服务器，分享给当前地点其他人；而暴力破解都知道是用数据字典中的数据一个个作为密码登录wifi，直到成功。 当然，也可以使用小米手机，wifi密码获取起来相对更容易。 更多方式希望有大神能补充补充。参考： 百度文库","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://zhujm.top/tags/android/"},{"name":"WiFi","slug":"WiFi","permalink":"http://zhujm.top/tags/WiFi/"}]},{"title":"mac 上AndroidStudio命令行gradlew执行出错","slug":"201908151319","date":"2018-06-15T05:19:22.000Z","updated":"2019-08-15T05:57:03.312Z","comments":true,"path":"2018/06/15/201908151319/","link":"","permalink":"http://zhujm.top/2018/06/15/201908151319/","excerpt":"问题一使用mac打包命令 ./gradlew assembleRelease 时，出现：","text":"问题一使用mac打包命令 ./gradlew assembleRelease 时，出现： 1env: bash\\r: No such file or directory 的错误，原因可能是gradlew 文件中含有非法字符了 解决方法： 用mac的AndroidStudio 重新创建一个安卓项目，将其中的gradlew文件复制到该出错的项目更目录替换原来的gradlew，再次运行即可正常执行。 问题二执行gradlew命令是出现 Promission Denide问题，没有权限执行的问题 解决方法： 执行 chmod +x gradlew 即可解决该问题。","categories":[{"name":"问题与解决","slug":"问题与解决","permalink":"http://zhujm.top/categories/问题与解决/"}],"tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://zhujm.top/tags/AndroidStudio/"},{"name":"Gradle","slug":"Gradle","permalink":"http://zhujm.top/tags/Gradle/"},{"name":"Mac","slug":"Mac","permalink":"http://zhujm.top/tags/Mac/"}]},{"title":"关于React-Native中的StaticRenderer组件","slug":"201908151313","date":"2018-06-15T05:13:58.000Z","updated":"2019-08-16T01:40:21.154Z","comments":true,"path":"2018/06/15/201908151313/","link":"","permalink":"http://zhujm.top/2018/06/15/201908151313/","excerpt":"ReactNative中内置了StaticRender组件，主要用在了listview与viewpager等组件的item中，对复用性及性能有一定的提升。 ../app/node_modules/react-native/Libraries/Components/StaticRenderer.js","text":"ReactNative中内置了StaticRender组件，主要用在了listview与viewpager等组件的item中，对复用性及性能有一定的提升。 ../app/node_modules/react-native/Libraries/Components/StaticRenderer.js 源码如下： 123456789101112131415161718192021222324252627'use strict';var React = require('React');var PropTypes = require('prop-types');class StaticRenderer extends React.Component &#123; props: &#123; shouldUpdate: boolean, render: Function, &#125;; static propTypes = &#123; shouldUpdate: PropTypes.bool.isRequired, render: PropTypes.func.isRequired, &#125;; shouldComponentUpdate(nextProps: &#123; shouldUpdate: boolean &#125;): boolean &#123; return nextProps.shouldUpdate; &#125; render(): React.Element&lt;any&gt; &#123; return this.props.render(); &#125;&#125;module.exports = StaticRenderer; 很简短的源码。StaticRenderer渲染效果完全由props的render函数来决定，并且根据shouldComponentUpdate回调函数的返回值也就是props.shouldUpdate，来决定了是否会re-render包裹的组件，如果将shouldUpdate设置为false，则就不能通过父组件改变子组件的props触发子组件re-render了，组件的页面状态完全由初始的props来决定，形成一种静态页面。 所以在ListView中我们的所有item的Component的都是props所决定的一次性的结果，不能进行re-render。如果要进行re-render，就只有改变dataSource触发ListView组件re-render。","categories":[{"name":"技术","slug":"技术","permalink":"http://zhujm.top/categories/技术/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://zhujm.top/tags/ReactNative/"},{"name":"性能优化","slug":"性能优化","permalink":"http://zhujm.top/tags/性能优化/"}]},{"title":"简单破解一款安卓软件","slug":"201908151029","date":"2018-03-22T03:32:08.000Z","updated":"2019-08-16T01:39:05.638Z","comments":true,"path":"2018/03/22/201908151029/","link":"","permalink":"http://zhujm.top/2018/03/22/201908151029/","excerpt":"下载apktool工具从官方渠道下载→官方下载","text":"下载apktool工具从官方渠道下载→官方下载 简单的命令:1234567891011121314151617181920$ apktool d test.apkI: Using Apktool 2.3.4 on test.apkI: Loading resource table...I: Decoding AndroidManifest.xml with resources...I: Loading resource table from file: 1.apkI: Regular manifest package...I: Decoding file-resources...I: Decoding values */* XMLs...I: Baksmaling classes.dex...I: Copying assets and libs...I: Copying unknown files...I: Copying original files...$ apktool b testI: Using Apktool 2.3.4 on testI: Checking whether sources has changed...I: Smaling smali folder into classes.dex...I: Checking whether resources has changed...I: Building resources...I: Building apk file...I: Copying unknown files/dir... 主要用到这两个命令。 应用市场摘取一枚apk此处简单以youdaonote.apk为例 执行完毕apktool d xxx.apk后，会在同级目录下生成一个文件夹 在IntelliJ IDEA中打开 尝试破解-非vip可使用壁纸（在该应用中，非vip是无法使用特定壁纸）此处需要了解简单的smali语法参考：https://www.cnblogs.com/sevck/p/6844513.html之后就是可以全局查找，浏览等等手段，定位到关键代码位置，修改smali代码，再通过上面的命令来完成重新打包，再签名，即得一枚破解包。 1- apktool b test 后记这里只是简单的记录下破解手段，因为自家app也被破解了，必须得知己知彼。破解软件不安全，用不得，此处仅供学习。 12345# 反编译apktool d app-release.apk -o outdir # 回编译（生成的apk默认放在outdir/dist目录中）apktool b outdir","categories":[{"name":"技术","slug":"技术","permalink":"http://zhujm.top/categories/技术/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhujm.top/tags/android/"},{"name":"逆向","slug":"逆向","permalink":"http://zhujm.top/tags/逆向/"}]},{"title":"浅析React-Native WebView,实现RN代码与Html的简单交互","slug":"201908151301","date":"2017-12-06T05:01:58.000Z","updated":"2019-08-16T01:39:05.640Z","comments":true,"path":"2017/12/06/201908151301/","link":"","permalink":"http://zhujm.top/2017/12/06/201908151301/","excerpt":"前言 基于React-Native0.41及0.25两个版本来分析","text":"前言 基于React-Native0.41及0.25两个版本来分析 公司项目基于ReactNative开发，最近有个需求为嵌入Web页面至应用中，分析需求发现技术实现中涉及了Web页面与app代码之间的交互，这对于原生来说实现并不难，但对于接触不久的RN来说，实现起来有点难度。下面结合React-Native WebView API来分析WebView的使用及简单的交互。 以下内容包括： React-Native WebView API 属性介绍 webview 实现与RN代码简单交互 在Android原生代码中对ReactNative WebView控件进行初始设置 React-Native WebView首先结合React-Native 高版本与低版本（0.41.2 与 0.25.1）分析其RN源码（偏向于Android方向）及api WebViewWebView 作为一个RN组件也是有其生命周期方法，翻开源码，查看其render方法，其return返回值如下： 123456return ( &lt;View style=&#123;styles.container&#125;&gt; &#123;webView&#125; &#123;otherView&#125; &lt;/View&gt; ); 从此处可以看出，WebView只是一层壳，其包括了两层覆盖的View，其中{webView}为RCTWebView组件，映射原生RCTWebView组件，是真正加载web页面的组件，{otherView}分析其构造可以发现它主要用来渲染加载失败视图及加载中的提示视图。 {webView}render中定义webView变量的代码如下(高版本低版本部分属性有所出入)： 1234567891011121314151617181920212223var webView = &lt;RCTWebView ref=&#123;RCT_WEBVIEW_REF&#125; key=&quot;webViewKey&quot; style=&#123;webViewStyles&#125; source=&#123;resolveAssetSource(source)&#125; scalesPageToFit=&#123;this.props.scalesPageToFit&#125; injectedJavaScript=&#123;this.props.injectedJavaScript&#125; userAgent=&#123;this.props.userAgent&#125; javaScriptEnabled=&#123;this.props.javaScriptEnabled&#125; domStorageEnabled=&#123;this.props.domStorageEnabled&#125; messagingEnabled=&#123;typeof this.props.onMessage === &apos;function&apos;&#125; onMessage=&#123;this.onMessage&#125; contentInset=&#123;this.props.contentInset&#125; automaticallyAdjustContentInsets=&#123;this.props.automaticallyAdjustContentInsets&#125; onContentSizeChange=&#123;this.props.onContentSizeChange&#125; onLoadingStart=&#123;this.onLoadingStart&#125; onLoadingFinish=&#123;this.onLoadingFinish&#125; onLoadingError=&#123;this.onLoadingError&#125; testID=&#123;this.props.testID&#125; mediaPlaybackRequiresUserAction=&#123;this.props.mediaPlaybackRequiresUserAction&#125; allowUniversalAccessFromFileURLs=&#123;this.props.allowUniversalAccessFromFileURLs&#125; /&gt;; 所设置的属性在webView Api几乎都有介绍，但部分属性却没有说明，大概分析下： scalesPageToFit bool 其对应Android端桥接方法为： 1234@ReactProp(name = &quot;scalesPageToFit&quot;) public void setScalesPageToFit(WebView view, boolean enabled) &#123; view.getSettings().setUseWideViewPort(!enabled);//android原生WebView设置此属性,可任意比例缩放 &#125; 由此可知，设置是否要把网页缩放到适应视图的大小，以及是否允许用户改变缩放比例。RN实现中其值默认设置为true。 injectedJavaScript 设置在网页加载之前注入的一段JS代码。 userAgent 其对应Android端桥接方法为： 1234567@ReactProp(name = &quot;userAgent&quot;)public void setUserAgent(WebView view, @Nullable String userAgent) &#123; if (userAgent != null) &#123; // TODO(8496850): Fix incorrect behavior when property is unset (uA == null) view.getSettings().setUserAgentString(userAgent); &#125;&#125; RN源码注释： Sets the user-agent for this WebView. The user-agent can also be set in native using WebViewConfig. This prop will overwrite that config. 综合上面信息，可知该属性为设置浏览器标识，也可通过原生接口WebViewConfig实现定制WebView,下面会稍作详细介绍如何使用WebViewConfig。 domStorageEnabled 其对应Android端桥接方法为： 1234@ReactProp(name = &quot;domStorageEnabled&quot;)public void setDomStorageEnabled(WebView view, boolean enabled) &#123; view.getSettings().setDomStorageEnabled(enabled);&#125; 该属性定义指定是否开启DOM本地存储。（仅限Android平台），具体可参考：http://blog.csdn.net/a345017062/article/details/8703221 messagingEnabled bool onMessage 这两个属性支持高版本ReactNative Api 低版本无此属性。messagingEnabled参数控制onMessage函数是否有效，如果不主动设置，则该值为onMessage函数是否定义的结果为值。 onMessage为function类型，官方api解释为: 在webview内部的网页中调用window.postMessage方法时可以触发此属性对应的函数，从而实现网页和RN之间的数据交换。 设置此属性的同时会在webview中注入一个postMessage的全局函数并覆盖可能已经存在的同名实现。网页端的window.postMessage只发送一个参数data，此参数封装在RN端的event对象中，即event.nativeEvent.data。data 只能是一个字符串。 Android原生中实现为 123456789101112131415161718192021222324252627282930313233343536373839404142 @ReactProp(name = &quot;messagingEnabled&quot;) public void setMessagingEnabled(WebView view, boolean enabled) &#123; ((ReactWebView) view).setMessagingEnabled(enabled); &#125; public void setMessagingEnabled(boolean enabled) &#123; if (messagingEnabled == enabled) &#123; return; &#125; messagingEnabled = enabled; if (enabled) &#123; addJavascriptInterface(new ReactWebViewBridge(this), BRIDGE_NAME); linkBridge(); &#125; else &#123; removeJavascriptInterface(BRIDGE_NAME); &#125;&#125;public void linkBridge() &#123; if (messagingEnabled) &#123; if (ReactBuildConfig.DEBUG &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; // See isNative in lodash String testPostMessageNative = &quot;String(window.postMessage) === String(Object.hasOwnProperty).replace(&apos;hasOwnProperty&apos;, &apos;postMessage&apos;)&quot;; evaluateJavascript(testPostMessageNative, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; if (value.equals(&quot;true&quot;)) &#123; FLog.w(ReactConstants.TAG, &quot;Setting onMessage on a WebView overrides existing values of window.postMessage, but a previous value was defined&quot;); &#125; &#125; &#125;); &#125; loadUrl(&quot;javascript:(&quot; + &quot;window.originalPostMessage = window.postMessage,&quot; + &quot;window.postMessage = function(data) &#123;&quot; + BRIDGE_NAME + &quot;.postMessage(String(data));&quot; + &quot;&#125;&quot; + &quot;)&quot;); &#125;&#125; 原生中实现是调用webView的loadUrl()，执行一段js代码，实现代码的注入。 定义该函数，即可实现网页端与RN代码之间的数据交互，下面详细介绍。 onContentSizeChange func 该函数在Rn api上并未提及，且在低版本rn上并没有其对应Android端桥接方法为： 12345678@ReactProp(name = &quot;onContentSizeChange&quot;)public void setOnContentSizeChange(WebView view, boolean sendContentSizeChangeEvents) &#123; if (sendContentSizeChangeEvents) &#123; view.setPictureListener(getPictureListener()); &#125; else &#123; view.setPictureListener(null); &#125;&#125; 结合Android Api可知，该函数用途为定义网页中图片加载完毕的状态回调。这个方法已经被Android标为弃用,这个对应的picture并不包含复合层或可以滚动的Div,只能被使用来侦测WebView内容的变化.在以后的版本会提供他的替代事件,所以该属性可不用。 其他属性可参看RN源码解释与官方Api。 {otherView}在render中，otherView是这么赋值的： 12345678910111213 var otherView = null;if (this.state.viewState === WebViewState.LOADING) &#123; otherView = (this.props.renderLoading || defaultRenderLoading)(); &#125; else if (this.state.viewState === WebViewState.ERROR) &#123; var errorEvent = this.state.lastErrorEvent; otherView = this.props.renderError &amp;&amp; this.props.renderError( errorEvent.domain, errorEvent.code, errorEvent.description); &#125; else if (this.state.viewState !== WebViewState.IDLE) &#123; console.error(&apos;RCTWebView invalid state encountered: &apos; + this.state.loading); &#125; 可直观看出，otherView根据WebView不同状态绘制提示页的。 renderLoading func 绘制加载中提示页 renderError func 绘制加载错误提示页 其他属性 onNavigationStateChange func 源码注释如下: We return an event with a bunch of fields including: url, title, loading, canGoBack, canGoForward 具体为重写该函数可在webView状态发生改变的时候回调webView的event信息,event信息里包含了url, title, loading, canGoBack, canGoForward. startInLoadingState bool 源码中的注释： force WebView to show loadingView on first load 具体为设置第一次加载数据时是否显示loading状态视图，默认值为true. webview 实现与RN代码简单交互不管安卓还是ios App,当内嵌webView加载网页时，多少都会有涉及网页端代码与原生代码之间的交互。 比如对原生代码返回键的监听，来实现对当网页可返回时点击app返回键不关闭网页，而是打开前一个网页，当没有前一个网页时，关闭当前webView页面，返回App上个页面。 这里涉及了app端与原生代码之间的简单交互,下面来说说我是怎么简单在高版本，低版本上实现的。 使用高低版本都有的属性方法–onNavigationStateChange这个函数上面介绍过，重写该回调时会传入一个event参数，event封装了url, title, loading, canGoBack, canGoForward五个方法。且每次webView状态改变时会回调该函数，很简单，通过url来判断。 123456onNavigationStateChange=&#123;this.onNavigationStateChange&#125;//在WebView中注册该回调方法onNavigationStateChange(event)&#123; console.log('onNavigationStateChange:'); console.log(event); //打印出event中属性 &#125; event的打印结果如下图： 这里便可直观的获取到WebView的重要状态属性，url为点击html标签触发的超链接，这里自定义成app能判断的协议链接，即可实现简单交互，举例点击网页按钮退出webView，即可用该方法实现。其他值如canGoBack,canGoForword,title，见名之意。但有个属性target有些疑惑，咱打开android源码看看： 123456789101112private WritableMap createWebViewEvent(WebView webView, String url) &#123; WritableMap event = Arguments.createMap(); event.putDouble(\"target\", webView.getId()); // Don't use webView.getUrl() here, the URL isn't updated to the new value yet in callbacks // like onPageFinished event.putString(\"url\", url); event.putBoolean(\"loading\", !mLastLoadFailed &amp;&amp; webView.getProgress() != 100); event.putString(\"title\", webView.getTitle()); event.putBoolean(\"canGoBack\", webView.canGoBack()); event.putBoolean(\"canGoForward\", webView.canGoForward()); return event;&#125; target也就是原生WebView的getId()返回值，也就是android中布局文件里的id值，这里算是唯一标识吧应该。 使用高版本的属性方法–onMessage(event)这个函数在RN官方API中有介绍，专门用来进行网页端与RN端的通信，这里来实现下。 12345onMessage=&#123;this.onMessage&#125; onMessage(event)&#123; console.log('onMessage-&gt;event.nativeEvent.data:'); console.log(event.nativeEvent.data); &#125; 在html代码中通过点击方式发送data: 12345&lt;script language=\"javascript\"&gt; $('#btn_msg1').click(function() &#123; window.postMessage('网页端点击了按钮啦。。。') &#125;);&lt;/script&gt; 结果： WebView Javascript Bridge该三方库兼容低版本实现网页端发送message,并可实现rn向html代码交互。参看：https://github.com/alinz/react-native-webview-bridge实现起来，稍微复杂些，安卓IOS端都需引入依赖。其通过注入js的方式，在html中注入 WebViewBridge.onMessage函数，实现了html与RN之间的双向交互，功能强大，具体看其api。 在Android原生代码中对ReactNative WebView控件进行初始设置翻开Android端桥接WebView的源码ReactWebViewManager，发现其有两个构造参数： 1234567891011121314151617 public ReactWebViewManager() &#123; mWebViewConfig = new WebViewConfig() &#123; public void configWebView(WebView webView) &#123; &#125; &#125;; &#125; public ReactWebViewManager(WebViewConfig webViewConfig) &#123; mWebViewConfig = webViewConfig; &#125;@Override protected WebView createViewInstance(ThemedReactContext reactContext) &#123; //... mWebViewConfig.configWebView(webView); //... return webView; &#125; 再打开WebViewConfig接口： 123public interface WebViewConfig &#123; void configWebView(WebView webView);&#125; 这里就可以看出，其实咱可以传入个WebViewConfig实例,通过webView.getSettings()对WebView进行Setting，下面简单实现下。由于MainReactPackage.java里已经将ReactWebViewManager进行无参实例化，并加入集合通过createViewManagers()返回。所以我觉得可通过继承的方式重写createViewManagers()返回值。 12345678910111213141516171819202122232425262728public class CusMainReactPackage extends MainReactPackage &#123; private WebViewConfig webViewConfig = new WebViewConfig() &#123; @Override public void configWebView(WebView webView) &#123; WebSettings settings = webView.getSettings(); //do settings... &#125; &#125;; @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123; List&lt;ViewManager&gt; viewManagers = handleRepleaceRTCWebView(super.createViewManagers(reactContext)); return viewManagers; &#125; /** * 替换viewManager中默认的RCTWebViewManager */ private List&lt;ViewManager&gt; handleRepleaceRTCWebView(List&lt;ViewManager&gt; viewManagers) &#123; List&lt;ViewManager&gt; _viewManagers = new ArrayList&lt;&gt;(viewManagers); for (int i = 0; i &lt; _viewManagers.size(); i++) if (_viewManagers.get(i).getName().equals(\"RCTWebView\")) &#123; _viewManagers.set(i, new ReactWebViewManager(webViewConfig)); break; &#125; return _viewManagers; &#125;&#125; 之后进行相应调用修改即可。 结束以上都是结合ReactNative Andorid端对WebView组件进行学习研究的总结，由于对RN接触不久，所以肯定有些理解错误的地方，望指正建议，谢谢！ 参考： http://reactnative.cn/docs/0.42/webview.html http://facebook.github.io/react-native/releases/0.25/docs/webview.html#webview https://github.com/alinz/react-native-webview-bridge http://blog.csdn.net/codetomylaw/article/details/52490378 https://developer.android.com/reference/android/webkit/WebView.html","categories":[{"name":"技术","slug":"技术","permalink":"http://zhujm.top/categories/技术/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhujm.top/tags/android/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://zhujm.top/tags/ReactNative/"}]},{"title":"探究WebView getContentHeight的内部实现看看是否需要进行额外计算","slug":"201908150947","date":"2017-11-22T03:32:08.000Z","updated":"2019-08-16T01:40:45.372Z","comments":true,"path":"2017/11/22/201908150947/","link":"","permalink":"http://zhujm.top/2017/11/22/201908150947/","excerpt":"先从WebView入手 WebView.java12345678910/** * Gets the height of the HTML content. * * @return the height of the HTML content */@ViewDebug.ExportedProperty(category = \"webview\")public int getContentHeight() &#123; checkThread(); return mProvider.getContentHeight();&#125;","text":"先从WebView入手 WebView.java12345678910/** * Gets the height of the HTML content. * * @return the height of the HTML content */@ViewDebug.ExportedProperty(category = \"webview\")public int getContentHeight() &#123; checkThread(); return mProvider.getContentHeight();&#125; 再找mProvider的实现 WebView.java12345678private void ensureProviderCreated() &#123; checkThread(); if (mProvider == null) &#123; // As this can get called during the base class constructor chain, pass the minimum // number of dependencies here; the rest are deferred to init(). mProvider = getFactory().createWebView(this, new PrivateAccess()); &#125;&#125; getFactory()是关键 WebView.java123private static WebViewFactoryProvider getFactory() &#123; return WebViewFactory.getProvider();&#125; 查看WebViewFactory.getProvider(),直接看return WebViewFactory.java123456789101112131415161718192021222324252627static WebViewFactoryProvider getProvider() &#123; //... if (sProviderInstance != null) return sProviderInstance; //... try &#123; Class&lt;WebViewFactoryProvider&gt; providerClass = getProviderClass(); Method staticFactory = null; try &#123; staticFactory = providerClass.getMethod( CHROMIUM_WEBVIEW_FACTORY_METHOD, WebViewDelegate.class); &#125; catch (Exception e) &#123; if (DEBUG) &#123; Log.w(LOGTAG, &quot;error instantiating provider with static factory method&quot;, e); &#125; &#125; //... try &#123; sProviderInstance = (WebViewFactoryProvider) staticFactory.invoke(null, new WebViewDelegate()); if (DEBUG) Log.v(LOGTAG, &quot;Loaded provider: &quot; + sProviderInstance); return sProviderInstance; &#125; catch (Exception e) &#123; //...&#125; 用到了反射，关键的getProviderClass()，也是直接看return WebViewFactory.java1234567891011121314151617private static Class&lt;WebViewFactoryProvider&gt; getProviderClass() &#123; //... try &#123; return getWebViewProviderClass(clazzLoader); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_WEBVIEW); &#125; //... try &#123; return (Class&lt;WebViewFactoryProvider&gt;) Class.forName(NULL_WEBVIEW_FACTORY); &#125; catch (ClassNotFoundException e2) &#123; // Ignore. &#125; //...&#125; 第二个return可以不用关心，因为有null,关注第一个return WebViewFactory.java12345678/** * @hide */public static Class&lt;WebViewFactoryProvider&gt; getWebViewProviderClass(ClassLoader clazzLoader) throws ClassNotFoundException &#123; return (Class&lt;WebViewFactoryProvider&gt;) Class.forName(CHROMIUM_WEBVIEW_FACTORY, true, clazzLoader);&#125; 隐藏方法，看看CHROMIUM_WEBVIEW_FACTORY是什么东东 WebViewFactory.java123/** @hide */private static final String CHROMIUM_WEBVIEW_FACTORY = &quot;com.android.webview.chromium.WebViewChromiumFactoryProviderForO&quot;; OK,反射了这个类，去sdk source里找找 …找啊找…发现在android-19,android-20,android-22里找到，高版本的都是null实现 随便找个android-22吧，路径如下： android-sdk\\sources\\android-22\\com\\android\\webview\\chromium\\WebViewChromiumFactoryProvider.java 回到上面getProviderClass()完毕，反射出WebViewChromiumFactoryProvider实例，就可以执行其createWebView()方法了 WebViewChromiumFactoryProvider.java123456789101112 @Overridepublic WebViewProvider createWebView(WebView webView, WebView.PrivateAccess privateAccess) &#123; WebViewChromium wvc = new WebViewChromium(this, webView, privateAccess); synchronized (mLock) &#123; if (mWebViewsToStart != null) &#123; mWebViewsToStart.add(new WeakReference&lt;WebViewChromium&gt;(wvc)); &#125; &#125; return wvc;&#125; OK 真正的实现找到了—&gt;WebViewChromium.java，并且在同目录下 至此，WebView的傀儡 WebViewProvider mProvider已揭开真面目 下一步肯定是不忘初心，看看getContentHeight()的实现啦 WebViewChromiumFactoryProvider.java123456@Overridepublic int getContentHeight() &#123; if (mAwContents == null) return 0; // No checkThread() as it is mostly thread safe (workaround for b/10594869). return mAwContents.getContentHeightCss();&#125; 又是桥接其他类来实现，AwContents.java，在 org.chromium.android_webview.AwContents; AwContents提供的不是WebView的API，所以，需要一层桥接部分，将AwContents桥接到WebView，这就是图中的桥接模块，该模块位于Android源代码中的frameworks/webview/chromium/java/com/android/webview/chromium/目录下，WebViewChromium和WebViewChromiumFactory类作为WebView的具体实现，依赖于Chromium项目的AwContents模块。 github clone 一个Chromium项目看看https://android.googlesource.com/platform/external/chromium_org 找啊找在\\chromium_org\\android_webview\\java\\src\\org\\chromium\\android_webview目录下找到AwContents.java ok 查看其内部实现即可 AwContents.java123public int getContentHeightCss() &#123; return (int) Math.ceil(mContentHeightDip);&#125; 这里可以看出直接返回成员变量，未进行计算 那这个成员变量赋值在哪 AwContents.java12345678910@CalledByNativeprivate void updateScrollState(int maxContainerViewScrollOffsetX, int maxContainerViewScrollOffsetY, int contentWidthDip, int contentHeightDip, float pageScaleFactor, float minPageScaleFactor, float maxPageScaleFactor) &#123; mContentWidthDip = contentWidthDip; mContentHeightDip = contentHeightDip; mScrollOffsetManager.setMaxScrollOffset(maxContainerViewScrollOffsetX, maxContainerViewScrollOffsetY); setPageScaleFactorAndLimits(pageScaleFactor, minPageScaleFactor, maxPageScaleFactor);&#125; 在这里赋值，可以根据注解@CalledByNative看出是Native层主动回调出来进行设置。 （也可在该实现中查看其它webview操作的实现。） 所以得到了想要的答案。 参考：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1106/1921.html https://android.googlesource.com/platform/external/chromium_org","categories":[{"name":"技术","slug":"技术","permalink":"http://zhujm.top/categories/技术/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhujm.top/tags/android/"},{"name":"WebView","slug":"WebView","permalink":"http://zhujm.top/tags/WebView/"}]},{"title":"JS箭头函数与传统JavaScript函数使用","slug":"201908151303","date":"2017-09-11T05:01:58.000Z","updated":"2019-08-15T05:07:41.791Z","comments":true,"path":"2017/09/11/201908151303/","link":"","permalink":"http://zhujm.top/2017/09/11/201908151303/","excerpt":"箭头函数的特性： 对this的关联。箭头函数内置的this的值，取决于箭头函数在哪定义，而非箭头函数执行的上下文环境。 new不可用。箭头函数内不能使用new关键字来实例化对象，否则报错。 没有arguments对象。不能通过arguments对象访问传入参数，只能使用显式命名或其他ES6新特性来完成。 this不可变。函数内置的this不可变，在函数体内整个执行环境中未常量。 有这些这些差异的原因：对this的绑定是JavaScript错误的常见来源之一。容易丢失函数内置数值，或得出意外结果。其次，将箭头函数限制为使用固定this引用，有利于JavaScript引擎优化处理。","text":"箭头函数的特性： 对this的关联。箭头函数内置的this的值，取决于箭头函数在哪定义，而非箭头函数执行的上下文环境。 new不可用。箭头函数内不能使用new关键字来实例化对象，否则报错。 没有arguments对象。不能通过arguments对象访问传入参数，只能使用显式命名或其他ES6新特性来完成。 this不可变。函数内置的this不可变，在函数体内整个执行环境中未常量。 有这些这些差异的原因：对this的绑定是JavaScript错误的常见来源之一。容易丢失函数内置数值，或得出意外结果。其次，将箭头函数限制为使用固定this引用，有利于JavaScript引擎优化处理。 常见使用：12345678910111213//箭头函数返回单个值（当入参是一个不需要加（））var getItem=key=&gt;value;//返回运算表达式结果var sum=(n1,n2)=&gt;n1+n2;//返回运算表达式结果var sum2=()=&gt;1+1;//大括号函数体var sum3=(n1,n2)=&gt;&#123;return n1+n2;&#125;//箭头函数返回对象var getItem2=key=&gt;(&#123; id:key, name:'jm'&#125;) 使用普通的function声明函数：1234567891011var Comp = &#123; id='123' , init:function()&#123; document.addEventListener(\"click\", function(event) &#123; this.doSomething(event.type); // error &#125;, false); &#125;, doSomething:function(type)&#123; console.log(\"Handling \" + type + \" for \" + this.id); &#125;&#125; 这里，因为函数内部this关联问题，this会根据当前函数执行环境去取值，所以this.doSomething(event.type); 这里的this会指向全局对象，全局对象没有doSomething方法，就undefinde了。 解决：这里在函数中使用bind()将this与Comp明确关联起来，相当于又创建一个已关联现有this的新函数，即可解决问题。 1234567891011var Comp = &#123; id='123' , init:function()&#123; document.addEventListener(\"click\", （function(event) &#123; this.doSomething(event.type); // error &#125;）.bind(this), false); &#125;, doSomething:function(type)&#123; console.log(\"Handling \" + type + \" for \" + this.id); &#125;&#125; 当然，由于前面所述箭头函数内置的this的值，取决于箭头函数在哪定义，而非箭头函数执行的上下文环境。这里将function声明的函数替换为箭头函数，即可直接使用this.doSomething()了。 123456789var Comp = &#123; id='123' , init:function()&#123; document.addEventListener(\"click\", ()=&gt;this.doSomething(), false); &#125;, doSomething:function(type)&#123; console.log(\"Handling \" + type + \" for \" + this.id); &#125;&#125; 当然，箭头函数的声明方式也就决定了其简练性，使得代码直观，简单，值得去使用。 其他： 1.对箭头函数进行typeof操作会返回“function”。 2.箭头函数仍是Function的实例，故而instanceof的执行方式与传统函数一致。 3.call/apply/bind方法仍适用于箭头函数，但就算调用这些方法扩充当前作用域，this也依旧不会变化。箭头函数与传统函数最大的不同之处在，禁用new操作。 参考：http://www.jb51.net/article/50770.htm","categories":[{"name":"技术","slug":"技术","permalink":"http://zhujm.top/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zhujm.top/tags/JavaScript/"}]},{"title":"仿知乎日报的ReactNativ项目","slug":"201908151315","date":"2017-08-15T05:15:32.000Z","updated":"2019-08-16T01:39:05.634Z","comments":true,"path":"2017/08/15/201908151315/","link":"","permalink":"http://zhujm.top/2017/08/15/201908151315/","excerpt":"个人从零到一学习开发的高仿知乎日报App，使用ReactNative技术，Js代码达到90%以上，采用Redux架构。","text":"个人从零到一学习开发的高仿知乎日报App，使用ReactNative技术，Js代码达到90%以上，采用Redux架构。 有想了解及交流的童鞋可以戳进去看看，觉得还行可以给个star鼓励下哦。 项目地址：https://github.com/zhujiaming/zhihudailyrn 安卓演示apk下载： ReactNative：0.45.1 运行环境：Android &gt;=4.1IOS（即将适配） 运行效果： 项目仍在不断完善中，并且会在文章中分享coding过程中爬的坑以及学习到的知识，有任何问题或建议欢迎与我联系共同学习哈。邮箱：ah_zjm@163.comQQ：771407650","categories":[{"name":"个人项目","slug":"个人项目","permalink":"http://zhujm.top/categories/个人项目/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhujm.top/tags/android/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://zhujm.top/tags/ReactNative/"}]},{"title":"Hello World","slug":"hello-world","date":"2015-07-01T05:01:58.000Z","updated":"2019-08-15T05:11:20.540Z","comments":true,"path":"2015/07/01/hello-world/","link":"","permalink":"http://zhujm.top/2015/07/01/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}