{"meta":{"title":"jiaming","subtitle":"这里什么都没有...","description":"这里什么都没有...","author":"jiaming.zhu","url":"http://zhujm.top","root":"/"},"pages":[],"posts":[{"title":"AndriodStudio打开项目长时间无响应解决","slug":"201908151038","date":"2019-08-15T02:38:22.214Z","updated":"2019-08-15T02:40:29.017Z","comments":true,"path":"2019/08/15/201908151038/","link":"","permalink":"http://zhujm.top/2019/08/15/201908151038/","excerpt":"首次安装 AndroidStudio 后，基本都会经历一个漫长的 Gradle 构建工具下载过程，避免这个漫长的等待，那就只有手动下载。 手动下载 Gradle 构建工具并设置步骤：","text":"首次安装 AndroidStudio 后，基本都会经历一个漫长的 Gradle 构建工具下载过程，避免这个漫长的等待，那就只有手动下载。 手动下载 Gradle 构建工具并设置步骤： 打开 项目目录/gradle/wrapper/gradle-wrapper.properties 查看 distributionUrl 的值的 gradle 版本号（如：gradle-2.4-all.zip），便获得了该项目所需 Gradle 构建工具版本 点击这里或官方渠道选择相应的版本下载，下载速度相比 as 肯定快不少 下载完成，打开 user 目录下的一个/.gradle 文件夹(windows 与 mac 相似，都是用户目录下，并且需要设置显示隐藏文件，具体百度即可，如果没有./gradle，运行一遍 AndroidStudio，跑个项目后 kill AndroidStudio 便有了) 找到/.gradle/wrapper/dist/ 目录下肯定会有 gradle-x.x-all 的文件夹，且对应项目所需的版本号（没有则把该项目导入 AndroidStudio，然后在 as 下载过程中强制结束 as，即可找到该文件夹） 把上面下载好的 jar 包丢进去，重新跑 AndroidStudio，这时，便正常啦。","categories":[{"name":"devTools","slug":"devTools","permalink":"http://zhujm.top/categories/devTools/"}],"tags":[{"name":"android studio","slug":"android-studio","permalink":"http://zhujm.top/tags/android-studio/"},{"name":"gradle","slug":"gradle","permalink":"http://zhujm.top/tags/gradle/"}]},{"title":"简单破解一款安卓软件","slug":"201908151029","date":"2019-08-15T01:44:39.386Z","updated":"2019-08-15T02:57:42.404Z","comments":true,"path":"2019/08/15/201908151029/","link":"","permalink":"http://zhujm.top/2019/08/15/201908151029/","excerpt":"下载apktool工具从官方渠道下载→官方下载","text":"下载apktool工具从官方渠道下载→官方下载 简单的命令:1234567891011121314151617181920$ apktool d test.apkI: Using Apktool 2.3.4 on test.apkI: Loading resource table...I: Decoding AndroidManifest.xml with resources...I: Loading resource table from file: 1.apkI: Regular manifest package...I: Decoding file-resources...I: Decoding values */* XMLs...I: Baksmaling classes.dex...I: Copying assets and libs...I: Copying unknown files...I: Copying original files...$ apktool b testI: Using Apktool 2.3.4 on testI: Checking whether sources has changed...I: Smaling smali folder into classes.dex...I: Checking whether resources has changed...I: Building resources...I: Building apk file...I: Copying unknown files/dir... 主要用到这两个命令。 应用市场摘取一枚apk此处简单以youdaonote.apk为例 执行完毕apktool d xxx.apk后，会在同级目录下生成一个文件夹 在IntelliJ IDEA中打开 尝试破解-非vip可使用壁纸（在该应用中，非vip是无法使用特定壁纸）此处需要了解简单的smali语法参考：https://www.cnblogs.com/sevck/p/6844513.html之后就是可以全局查找，浏览等等手段，定位到关键代码位置，修改smali代码，再通过上面的命令来完成重新打包，再签名，即得一枚破解包。 1- apktool b test 后记这里只是简单的记录下破解手段，因为自家app也被破解了，必须得知己知彼。破解软件不安全，用不得，此处仅供学习。 12345# 反编译apktool d app-release.apk -o outdir # 回编译（生成的apk默认放在outdir/dist目录中）apktool b outdir","categories":[{"name":"android","slug":"android","permalink":"http://zhujm.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhujm.top/tags/android/"},{"name":"逆向","slug":"逆向","permalink":"http://zhujm.top/tags/逆向/"}]},{"title":"探究WebView getContentHeight的内部实现看看是否需要进行额外计算","slug":"201908150947","date":"2019-08-15T01:40:51.179Z","updated":"2019-08-15T02:37:54.759Z","comments":true,"path":"2019/08/15/201908150947/","link":"","permalink":"http://zhujm.top/2019/08/15/201908150947/","excerpt":"先从WebView入手 WebView.java12345678910/** * Gets the height of the HTML content. * * @return the height of the HTML content */@ViewDebug.ExportedProperty(category = \"webview\")public int getContentHeight() &#123; checkThread(); return mProvider.getContentHeight();&#125; 再找mProvider的实现","text":"先从WebView入手 WebView.java12345678910/** * Gets the height of the HTML content. * * @return the height of the HTML content */@ViewDebug.ExportedProperty(category = \"webview\")public int getContentHeight() &#123; checkThread(); return mProvider.getContentHeight();&#125; 再找mProvider的实现 WebView.java12345678private void ensureProviderCreated() &#123; checkThread(); if (mProvider == null) &#123; // As this can get called during the base class constructor chain, pass the minimum // number of dependencies here; the rest are deferred to init(). mProvider = getFactory().createWebView(this, new PrivateAccess()); &#125;&#125; getFactory()是关键 WebView.java123private static WebViewFactoryProvider getFactory() &#123; return WebViewFactory.getProvider();&#125; 查看WebViewFactory.getProvider(),直接看return WebViewFactory.java123456789101112131415161718192021222324252627static WebViewFactoryProvider getProvider() &#123; //... if (sProviderInstance != null) return sProviderInstance; //... try &#123; Class&lt;WebViewFactoryProvider&gt; providerClass = getProviderClass(); Method staticFactory = null; try &#123; staticFactory = providerClass.getMethod( CHROMIUM_WEBVIEW_FACTORY_METHOD, WebViewDelegate.class); &#125; catch (Exception e) &#123; if (DEBUG) &#123; Log.w(LOGTAG, &quot;error instantiating provider with static factory method&quot;, e); &#125; &#125; //... try &#123; sProviderInstance = (WebViewFactoryProvider) staticFactory.invoke(null, new WebViewDelegate()); if (DEBUG) Log.v(LOGTAG, &quot;Loaded provider: &quot; + sProviderInstance); return sProviderInstance; &#125; catch (Exception e) &#123; //...&#125; 用到了反射，关键的getProviderClass()，也是直接看return WebViewFactory.java1234567891011121314151617private static Class&lt;WebViewFactoryProvider&gt; getProviderClass() &#123; //... try &#123; return getWebViewProviderClass(clazzLoader); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_WEBVIEW); &#125; //... try &#123; return (Class&lt;WebViewFactoryProvider&gt;) Class.forName(NULL_WEBVIEW_FACTORY); &#125; catch (ClassNotFoundException e2) &#123; // Ignore. &#125; //...&#125; 第二个return可以不用关心，因为有null,关注第一个return WebViewFactory.java12345678/** * @hide */public static Class&lt;WebViewFactoryProvider&gt; getWebViewProviderClass(ClassLoader clazzLoader) throws ClassNotFoundException &#123; return (Class&lt;WebViewFactoryProvider&gt;) Class.forName(CHROMIUM_WEBVIEW_FACTORY, true, clazzLoader);&#125; 隐藏方法，看看CHROMIUM_WEBVIEW_FACTORY是什么东东 WebViewFactory.java123/** @hide */private static final String CHROMIUM_WEBVIEW_FACTORY = &quot;com.android.webview.chromium.WebViewChromiumFactoryProviderForO&quot;; OK,反射了这个类，去sdk source里找找 …找啊找…发现在android-19,android-20,android-22里找到，高版本的都是null实现 随便找个android-22吧，路径如下： android-sdk\\sources\\android-22\\com\\android\\webview\\chromium\\WebViewChromiumFactoryProvider.java 回到上面getProviderClass()完毕，反射出WebViewChromiumFactoryProvider实例，就可以执行其createWebView()方法了 WebViewChromiumFactoryProvider.java123456789101112 @Overridepublic WebViewProvider createWebView(WebView webView, WebView.PrivateAccess privateAccess) &#123; WebViewChromium wvc = new WebViewChromium(this, webView, privateAccess); synchronized (mLock) &#123; if (mWebViewsToStart != null) &#123; mWebViewsToStart.add(new WeakReference&lt;WebViewChromium&gt;(wvc)); &#125; &#125; return wvc;&#125; OK 真正的实现找到了—&gt;WebViewChromium.java，并且在同目录下 至此，WebView的傀儡 WebViewProvider mProvider已揭开真面目 下一步肯定是不忘初心，看看getContentHeight()的实现啦 WebViewChromiumFactoryProvider.java123456@Overridepublic int getContentHeight() &#123; if (mAwContents == null) return 0; // No checkThread() as it is mostly thread safe (workaround for b/10594869). return mAwContents.getContentHeightCss();&#125; 又是桥接其他类来实现，AwContents.java，在 org.chromium.android_webview.AwContents; AwContents提供的不是WebView的API，所以，需要一层桥接部分，将AwContents桥接到WebView，这就是图中的桥接模块，该模块位于Android源代码中的frameworks/webview/chromium/java/com/android/webview/chromium/目录下，WebViewChromium和WebViewChromiumFactory类作为WebView的具体实现，依赖于Chromium项目的AwContents模块。 github clone 一个Chromium项目看看https://android.googlesource.com/platform/external/chromium_org 找啊找在\\chromium_org\\android_webview\\java\\src\\org\\chromium\\android_webview目录下找到AwContents.java ok 查看其内部实现即可 AwContents.java123public int getContentHeightCss() &#123; return (int) Math.ceil(mContentHeightDip);&#125; 这里可以看出直接返回成员变量，未进行计算 那这个成员变量赋值在哪 AwContents.java12345678910@CalledByNativeprivate void updateScrollState(int maxContainerViewScrollOffsetX, int maxContainerViewScrollOffsetY, int contentWidthDip, int contentHeightDip, float pageScaleFactor, float minPageScaleFactor, float maxPageScaleFactor) &#123; mContentWidthDip = contentWidthDip; mContentHeightDip = contentHeightDip; mScrollOffsetManager.setMaxScrollOffset(maxContainerViewScrollOffsetX, maxContainerViewScrollOffsetY); setPageScaleFactorAndLimits(pageScaleFactor, minPageScaleFactor, maxPageScaleFactor);&#125; 在这里赋值，可以根据注解@CalledByNative看出是Native层主动回调出来进行设置。 （也可在该实现中查看其它webview操作的实现。） 所以得到了想要的答案。 参考：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1106/1921.html https://android.googlesource.com/platform/external/chromium_org","categories":[{"name":"android","slug":"android","permalink":"http://zhujm.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhujm.top/tags/android/"},{"name":"webview","slug":"webview","permalink":"http://zhujm.top/tags/webview/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-12T06:39:41.185Z","updated":"2019-08-15T02:41:10.539Z","comments":true,"path":"2019/08/12/hello-world/","link":"","permalink":"http://zhujm.top/2019/08/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}